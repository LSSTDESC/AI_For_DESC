<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DESC AI Chord Diagram</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: white;
        }
        #root {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            min-height: 0;
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 1rem;
        }
        .legend {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
            color: #475569;
        }
        .legend-color {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
        }
        .button-group {
            display: flex;
            gap: 0.75rem;
        }
        button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: 2px solid;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s;
        }
        .btn-toggle {
            border-color: #cbd5e1;
            background: white;
            color: #334155;
        }
        .btn-toggle:hover {
            border-color: #94a3b8;
        }
        .btn-toggle.active {
            border-color: #6366f1;
            background: #eef2ff;
            color: #4338ca;
        }
        .btn-clear {
            border-color: #cbd5e1;
            background: #f1f5f9;
            color: #334155;
        }
        .btn-clear:hover {
            background: #e2e8f0;
        }
        .svg-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            overflow: hidden;
        }
        svg {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }
        .cursor-pointer { cursor: pointer; }
        .pointer-events-none { pointer-events: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo } = React;

        const COLORS = {
            scienceCase: { color: '#A10034', bgColor: '#fce7ed' },
            methodology: { color: '#93A8AC', bgColor: '#f0f3f4' },
            challenge: { color: '#F3C969', bgColor: '#fef9ed' }
        };

        const DATA = [
          {
            id: 'photoz',
            name: 'Photo-z',
            methodologies: ['Simulation-Based Inference (SBI)\n& Density Estimation', 'Hierarchical Bayesian models', 'Emulators', 'Generative models'],
            challenges: ['Covariate shift', 'Uncertainty Quantification (UQ)', 'Scalability', 'Metrics & evaluation']
          },
          {
            id: 'stronglens',
            name: 'Strong Lensing',
            methodologies: ['Simulation-Based Inference (SBI)\n& Density Estimation', 'Generative models'],
            challenges: ['Data sparsity & rare events', 'Covariate shift', 'Uncertainty Quantification (UQ)']
          },
          {
            id: 'weaklens',
            name: 'Weak Lensing',
            methodologies: ['Simulation-Based Inference (SBI)\n& Density Estimation', 'Differentiable programming', 'Hierarchical Bayesian models', 'Generative models'],
            challenges: ['Covariate shift', 'Uncertainty Quantification (UQ)', 'Scalability']
          },
          {
            id: 'clusters',
            name: 'Galaxy Clusters',
            methodologies: ['Simulation-Based Inference (SBI)\n& Density Estimation', 'Hierarchical Bayesian models'],
            challenges: ['Covariate shift', 'Uncertainty Quantification (UQ)', 'Scalability']
          },
          {
            id: 'sn',
            name: 'Supernovae (SN) & Transients',
            methodologies: ['Simulation-Based Inference (SBI)\n& Density Estimation', 'Active learning', 'Anomaly detection', 'Hierarchical Bayesian models', 'Generative models'],
            challenges: ['Covariate shift', 'Data sparsity & rare events', 'Scalability', 'Uncertainty Quantification (UQ)']
          },
          {
            id: 'theory',
            name: 'Theory & Modeling',
            methodologies: ['Emulators', 'Differentiable programming', 'Simulation-Based Inference (SBI)\n& Density Estimation'],
            challenges: ['Covariate shift', 'Scalability']
          },
          {
            id: 'sims',
            name: 'Simulations',
            methodologies: ['Emulators', 'Generative models', 'Differentiable programming', 'Simulation-Based Inference (SBI)\n& Density Estimation'],
            challenges: ['Covariate shift', 'Scalability', 'Metrics & evaluation']
          },
          {
            id: 'classify',
            name: 'Object Classification',
            methodologies: ['Active learning'],
            challenges: ['Covariate shift', 'Data sparsity & rare events', 'Scalability', 'Uncertainty Quantification (UQ)']
          },
          {
            id: 'deblend',
            name: 'Deblending',
            methodologies: ['Generative models', 'Simulation-Based Inference (SBI)\n& Density Estimation'],
            challenges: ['Data sparsity & rare events', 'Metrics & evaluation', 'Uncertainty Quantification (UQ)']
          },
          {
            id: 'shape',
            name: 'Shape Measurement',
            methodologies: ['Differentiable programming', 'Simulation-Based Inference (SBI)\n& Density Estimation'],
            challenges: ['Covariate shift', 'Uncertainty Quantification (UQ)', 'Data sparsity & rare events', 'Scalability']
          }
        ];

        function processData() {
          const methodologies = new Map();
          const challenges = new Map();

          DATA.forEach(sc => {
            sc.methodologies.forEach(m => methodologies.set(m, (methodologies.get(m) || 0) + 1));
            sc.challenges.forEach(c => challenges.set(c, (challenges.get(c) || 0) + 1));
          });

          return {
            scienceCases: DATA,
            methodologies: Array.from(methodologies.keys()).sort(),
            challenges: Array.from(challenges.keys()).sort((a, b) =>
              (challenges.get(b) || 0) - (challenges.get(a) || 0)
            )
          };
        }

        function ChordDiagram() {
          const [hovered, setHovered] = useState({ type: null, value: null });
          const [locked, setLocked] = useState(null);
          const [paperMode, setPaperMode] = useState(false);

          const data = useMemo(() => processData(), []);
          const active = locked || hovered;

          const handleClick = (type, value) => {
            if (paperMode) return;
            setLocked(locked?.type === type && locked?.value === value ? null : { type, value });
          };

          const setHover = (type, value) => {
            if (!locked && !paperMode) setHovered({ type, value });
          };

          const clearHover = () => {
            if (!locked && !paperMode) setHovered({ type: null, value: null });
          };

          // SVG dimensions
          const centerX = 600, centerY = 500, radius = 380;

          // Calculate positions on circle
          const calcPositions = (items, startAngle, endAngle, margin) => {
            const positions = new Map();
            const sectionSize = endAngle - startAngle;
            const marginSize = sectionSize * margin;
            const step = (sectionSize - 2 * marginSize) / Math.max(1, items.length - 1);

            items.forEach((item, i) => {
              const angle = startAngle + marginSize + i * step;
              const rad = (angle * Math.PI) / 180;
              positions.set(item.id || item, {
                x: centerX + radius * Math.cos(rad),
                y: centerY + radius * Math.sin(rad),
                angle
              });
            });
            return positions;
          };

          const casePos = calcPositions(data.scienceCases, 93, 207, 0.1);
          const methodPos = calcPositions(data.methodologies, 213, 327, 0.05);
          const challengePos = calcPositions(data.challenges, 333, 447, 0.1);

          // Determine what to highlight
          const getHighlighted = () => {
            const cases = new Set(), methods = new Set(), challenges = new Set();

            if (active.type === 'case') {
              cases.add(active.value);
              const sc = data.scienceCases.find(s => s.id === active.value);
              sc?.methodologies.forEach(m => methods.add(m));
              sc?.challenges.forEach(c => challenges.add(c));
            }
            if (active.type === 'method') {
              methods.add(active.value);
              data.scienceCases.forEach(sc => {
                if (sc.methodologies.includes(active.value)) {
                  cases.add(sc.id);
                  sc.challenges.forEach(c => challenges.add(c));
                }
              });
            }
            if (active.type === 'challenge') {
              challenges.add(active.value);
              data.scienceCases.forEach(sc => {
                if (sc.challenges.includes(active.value)) {
                  cases.add(sc.id);
                  sc.methodologies.forEach(m => methods.add(m));
                }
              });
            }
            return { cases, methods, challenges };
          };

          const highlighted = getHighlighted();
          const hasSelection = !paperMode && active.type;

          // Generate chords
          const chords = [];
          data.scienceCases.forEach(sc => {
            const cPos = casePos.get(sc.id);

            // Science cases to methodologies
            sc.methodologies.forEach(method => {
              const mPos = methodPos.get(method);
              const isHighlighted = paperMode || (highlighted.cases.has(sc.id) && highlighted.methods.has(method));
              chords.push({
                path: `M ${cPos.x} ${cPos.y} Q ${centerX} ${centerY - 150} ${mPos.x} ${mPos.y}`,
                color: COLORS.methodology.color,
                opacity: paperMode ? 0.25 : (isHighlighted ? 0.7 : 0.1),
                width: isHighlighted ? 3 : 2,
                glow: isHighlighted && !paperMode
              });
            });

            // Science cases to challenges
            sc.challenges.forEach(challenge => {
              const chPos = challengePos.get(challenge);
              const isHighlighted = paperMode || (highlighted.cases.has(sc.id) && highlighted.challenges.has(challenge));
              chords.push({
                path: `M ${cPos.x} ${cPos.y} Q ${centerX + 150} ${centerY} ${chPos.x} ${chPos.y}`,
                color: COLORS.scienceCase.color,
                opacity: paperMode ? 0.2 : (isHighlighted ? 0.6 : 0.08),
                width: isHighlighted ? 2.5 : 1.5,
                glow: isHighlighted && !paperMode
              });
            });
          });

          // Methodologies to challenges
          const methodChallengeLinks = new Map();
          data.scienceCases.forEach(sc => {
            sc.methodologies.forEach(m => {
              sc.challenges.forEach(c => {
                methodChallengeLinks.set(`${m}::${c}`, true);
              });
            });
          });

          methodChallengeLinks.forEach((_, key) => {
            const [method, challenge] = key.split('::');
            const mPos = methodPos.get(method);
            const chPos = challengePos.get(challenge);
            const isHighlighted = paperMode || (highlighted.methods.has(method) && highlighted.challenges.has(challenge));
            chords.push({
              path: `M ${mPos.x} ${mPos.y} Q ${centerX} ${centerY + 150} ${chPos.x} ${chPos.y}`,
              color: COLORS.challenge.color,
              opacity: paperMode ? 0.2 : (isHighlighted ? 0.6 : 0.08),
              width: isHighlighted ? 2.5 : 1.5,
              glow: isHighlighted && !paperMode
            });
          });

          // Render node
          const renderNode = (item, pos, type, colorConfig, activeCheck, highlightCheck, labelRadius) => {
            const isActive = activeCheck(item);
            const isHighlighted = highlightCheck(item);
            const isDimmed = hasSelection && !isHighlighted;
            const labelRad = (pos.angle * Math.PI) / 180;
            const labelX = centerX + labelRadius * Math.cos(labelRad);
            const labelY = centerY + labelRadius * Math.sin(labelRad);

            let textAnchor = 'middle';
            if (type === 'case') textAnchor = pos.angle > 90 && pos.angle < 270 ? 'end' : 'start';
            if (type === 'challenge') textAnchor = pos.angle > 270 || pos.angle < 90 ? 'start' : 'end';
            if (type === 'method') textAnchor = pos.angle < 270 ? 'end' : 'start';

            return React.createElement('g', { key: item.id || item },
              React.createElement('circle', {
                cx: pos.x,
                cy: pos.y,
                r: isActive ? 14 : (type === 'method' ? 12 : 10),
                fill: (paperMode || isHighlighted || isActive) ? colorConfig.color : colorConfig.bgColor,
                stroke: colorConfig.color,
                strokeWidth: isActive ? 3 : 2,
                opacity: isDimmed ? 0.3 : 1,
                className: paperMode ? '' : 'cursor-pointer',
                style: { transition: 'all 0.2s ease' },
                onMouseEnter: () => setHover(type, item.id || item),
                onMouseLeave: clearHover,
                onClick: () => handleClick(type, item.id || item)
              }),
              React.createElement('text', {
                x: labelX,
                y: labelY,
                textAnchor,
                dominantBaseline: 'middle',
                className: 'pointer-events-none',
                fontSize: type === 'method' ? '16' : '17',
                fontWeight: isActive ? 'bold' : (type === 'method' ? '500' : 'normal'),
                fill: type === 'method' ? '#1e293b' : '#334155',
                opacity: isDimmed ? 0.3 : 1,
                style: { transition: 'all 0.2s ease' }
              }, (() => {
                const text = item.name || item;
                const lines = text.split('\n');
                if (lines.length > 1) {
                  // Estimate first line center for aligning second line beneath it
                  const firstLineWidth = 260; // approx width of "Simulation-Based Inference (SBI)" at 16px
                  const centerX = textAnchor === 'end' ? labelX - firstLineWidth / 2
                                : textAnchor === 'start' ? labelX + firstLineWidth / 2
                                : labelX;
                  return lines.map((line, i) => React.createElement('tspan', {
                    key: i,
                    x: i === 0 ? labelX : centerX,
                    dy: i === 0 ? '-0.6em' : '1.2em',
                    textAnchor: i === 0 ? undefined : 'middle'
                  }, line));
                }
                return text;
              })())
            );
          };

          return React.createElement('div', { className: 'container' },
            // Controls
            React.createElement('div', { className: 'controls' },
              !paperMode && React.createElement('div', { className: 'legend' },
                React.createElement('span', { style: { color: '#475569', fontSize: '0.95rem' } }, 'Interactive chord diagram'),
                React.createElement('div', { className: 'legend-item' },
                  React.createElement('div', { className: 'legend-color', style: { backgroundColor: COLORS.scienceCase.color } }),
                  React.createElement('span', null, 'Science ', React.createElement('br'), 'Cases')
                ),
                React.createElement('div', { className: 'legend-item' },
                  React.createElement('div', { className: 'legend-color', style: { backgroundColor: COLORS.methodology.color } }),
                  React.createElement('span', null, 'Methodologies')
                ),
                React.createElement('div', { className: 'legend-item' },
                  React.createElement('div', { className: 'legend-color', style: { backgroundColor: COLORS.challenge.color } }),
                  React.createElement('span', null, 'Challenges')
                )
              ),
              React.createElement('div', { className: 'button-group', style: paperMode ? { marginLeft: 'auto' } : {} },
                React.createElement('button', {
                  onClick: () => { setPaperMode(!paperMode); setLocked(null); },
                  className: 'btn-toggle' + (paperMode ? ' active' : '')
                }, paperMode ? 'Switch to Interactive' : 'Switch to Paper Mode'),
                locked && !paperMode && React.createElement('button', {
                  onClick: () => setLocked(null),
                  className: 'btn-clear'
                }, 'Clear selection')
              )
            ),

            // SVG Diagram
            React.createElement('div', { className: 'svg-container' },
              React.createElement('svg', { viewBox: '0 0 1200 1000', preserveAspectRatio: 'xMidYMid meet' },
                React.createElement('defs', null,
                  React.createElement('filter', { id: 'glow' },
                    React.createElement('feGaussianBlur', { stdDeviation: '3', result: 'blur' }),
                    React.createElement('feMerge', null,
                      React.createElement('feMergeNode', { in: 'blur' }),
                      React.createElement('feMergeNode', { in: 'SourceGraphic' })
                    )
                  )
                ),

                // Logo
                React.createElement('image', {
                  href: 'desc_logo.png',
                  x: 10,
                  y: 10,
                  height: 140,
                  preserveAspectRatio: 'xMinYMin meet'
                }),

                // Background circle
                React.createElement('circle', {
                  cx: centerX,
                  cy: centerY,
                  r: radius,
                  fill: 'none',
                  stroke: '#f1f5f9',
                  strokeWidth: '1'
                }),

                // Section arcs
                [
                  { start: 90, end: 210, color: COLORS.scienceCase.color },
                  { start: 210, end: 330, color: COLORS.methodology.color },
                  { start: 330, end: 450, color: COLORS.challenge.color }
                ].map((arc, i) => {
                  const startRad = (arc.start * Math.PI) / 180;
                  const endRad = (arc.end * Math.PI) / 180;
                  const startX = centerX + radius * Math.cos(startRad);
                  const startY = centerY + radius * Math.sin(startRad);
                  const endX = centerX + radius * Math.cos(endRad);
                  const endY = centerY + radius * Math.sin(endRad);
                  const largeArc = arc.end - arc.start > 180 ? 1 : 0;

                  return React.createElement('path', {
                    key: i,
                    d: `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArc} 1 ${endX} ${endY}`,
                    fill: 'none',
                    stroke: arc.color,
                    strokeWidth: '6',
                    strokeOpacity: '0.4'
                  });
                }),

                // Boundary lines
                [90, 210, 330].map(angle => {
                  const rad = (angle * Math.PI) / 180;
                  return React.createElement('line', {
                    key: angle,
                    x1: centerX,
                    y1: centerY,
                    x2: centerX + (radius + 30) * Math.cos(rad),
                    y2: centerY + (radius + 30) * Math.sin(rad),
                    stroke: '#cbd5e1',
                    strokeWidth: '2',
                    strokeDasharray: '4,4',
                    opacity: '0.6'
                  });
                }),

                // Chords
                React.createElement('g', null,
                  chords.map((chord, i) =>
                    React.createElement('path', {
                      key: i,
                      d: chord.path,
                      stroke: chord.color,
                      strokeWidth: chord.width,
                      strokeOpacity: chord.opacity,
                      fill: 'none',
                      strokeLinecap: 'round',
                      style: {
                        transition: 'all 0.3s ease',
                        filter: chord.glow ? 'url(#glow)' : 'none'
                      }
                    })
                  )
                ),

                // Science cases
                data.scienceCases.map(sc => renderNode(
                  sc,
                  casePos.get(sc.id),
                  'case',
                  COLORS.scienceCase,
                  (s) => active.type === 'case' && active.value === s.id,
                  (s) => highlighted.cases.has(s.id),
                  410
                )),

                // Methodologies
                data.methodologies.map(method => renderNode(
                  method,
                  methodPos.get(method),
                  'method',
                  COLORS.methodology,
                  (m) => active.type === 'method' && active.value === m,
                  (m) => highlighted.methods.has(m),
                  420
                )),

                // Challenges
                data.challenges.map(challenge => renderNode(
                  challenge,
                  challengePos.get(challenge),
                  'challenge',
                  COLORS.challenge,
                  (c) => active.type === 'challenge' && active.value === c,
                  (c) => highlighted.challenges.has(c),
                  410
                )),

                // Section labels
                [
                  { label: 'Science\nCases', angle: 150, offset: 230 },
                  { label: 'Methodologies', angle: 270, offset: 100 },
                  { label: 'Challenges', angle: 30, offset: 230 }
                ].map(({ label, angle, offset }) => {
                  const rad = (angle * Math.PI) / 180;
                  const lines = label.split('\n');
                  return React.createElement('text', {
                    key: label,
                    x: centerX + (radius + offset) * Math.cos(rad),
                    y: centerY + (radius + offset) * Math.sin(rad),
                    textAnchor: 'middle',
                    dominantBaseline: angle === 270 ? 'hanging' : 'middle',
                    fontSize: '24',
                    fontWeight: '700',
                    fill: '#424b54'
                  }, lines.length > 1
                    ? lines.map((line, i) => React.createElement('tspan', { key: i, x: centerX + (radius + offset) * Math.cos(rad), dy: i === 0 ? '-0.6em' : '1.2em' }, line))
                    : label);
                })
              )
            )
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(ChordDiagram));
    </script>
</body>
</html>
