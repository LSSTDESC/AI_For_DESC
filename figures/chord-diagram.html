<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DESC AI Chord Diagram</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: white;
        }

        /* Tailwind-like classes used in the component */
        .bg-white { background-color: white; }
        .rounded-xl { border-radius: 0.75rem; }
        .shadow-lg { box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .border { border-width: 1px; }
        .border-slate-200 { border-color: #e2e8f0; }
        .p-8 { padding: 2rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-6 { gap: 1.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-3 { gap: 0.75rem; }
        .gap-2 { gap: 0.5rem; }
        .flex-wrap { flex-wrap: wrap; }
        .pb-6 { padding-bottom: 1.5rem; }
        .border-b { border-bottom-width: 1px; }
        .w-4 { width: 1rem; }
        .h-4 { height: 1rem; }
        .text-slate-600 { color: #475569; }
        .text-slate-700 { color: #334155; }
        .text-slate-800 { color: #1e293b; }
        .text-slate-500 { color: #64748b; }
        .rounded { border-radius: 0.25rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .border-2 { border-width: 2px; }
        .transition-all { transition: all 0.3s ease; }
        .transition-colors { transition: background-color 0.3s ease, color 0.3s ease; }
        .border-indigo-500 { border-color: #6366f1; }
        .bg-indigo-50 { background-color: #eef2ff; }
        .text-indigo-700 { color: #4338ca; }
        .text-indigo-900 { color: #312e81; }
        .text-indigo-600 { color: #4f46e5; }
        .border-slate-300 { border-color: #cbd5e1; }
        .hover\:border-slate-400:hover { border-color: #94a3b8; }
        .bg-slate-100 { background-color: #f1f5f9; }
        .hover\:bg-slate-200:hover { background-color: #e2e8f0; }
        .relative { position: relative; }
        .justify-center { justify-content: center; }
        .max-w-full { max-width: 100%; }
        .cursor-pointer { cursor: pointer; }
        .pointer-events-none { pointer-events: none; }
        .mt-6 { margin-top: 1.5rem; }
        .pt-6 { padding-top: 1.5rem; }
        .border-t { border-top-width: 1px; }
        .p-4 { padding: 1rem; }
        .border-indigo-200 { border-color: #c7d2fe; }
        .mb-2 { margin-bottom: 0.5rem; }
        .grid { display: grid; }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .mt-3 { margin-top: 0.75rem; }
        .bg-blue-50 { background-color: #eff6ff; }
        .border-blue-200 { border-color: #bfdbfe; }
        .text-blue-900 { color: #1e3a8a; }

        /* Hide Lucide icons since we'll use simple alternatives */
        .lucide-icon { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo } = React;

        const rawData = [
          {
            id: 'photoz',
            name: '3.1.1 Photometric redshifts',
            shortName: 'Photo-z',
            methodologies: ['SBI', 'Self-Organizing Maps', 'Deep learning', 'Hierarchical Bayesian models', 'Emulators'],
            challenges: ['UQ & calibration', 'Scalability & compute efficiency', 'Covariate shift & domain adaptation']
          },
          {
            id: 'stronglens',
            name: '3.1.2 Strong Lensing',
            shortName: 'Strong Lensing',
            methodologies: ['Deep learning', 'SBI', 'Anomaly detection'],
            challenges: ['Data sparsity & rare events']
          },
          {
            id: 'weaklens',
            name: '3.1.3 Weak Lensing',
            shortName: 'Weak Lensing',
            methodologies: ['SBI', 'Neural compression', 'Differentiable programming'],
            challenges: ['UQ & calibration', 'Scalability & compute efficiency']
          },
          {
            id: 'clusters',
            name: '3.1.4 Galaxy Clusters',
            shortName: 'Galaxy Clusters',
            methodologies: ['SBI'],
            challenges: ['Covariate shift & domain adaptation', 'UQ & calibration']
          },
          {
            id: 'sn',
            name: '3.1.5 Supernova cosmology & transients',
            shortName: 'SN & Transients',
            methodologies: ['Deep learning', 'Active learning'],
            challenges: ['Covariate shift & domain adaptation', 'Model misspecification', 'Data sparsity & rare events', 'Scalability & compute efficiency']
          },
          {
            id: 'theory',
            name: '3.1.6 Theory & Modeling',
            shortName: 'Theory & Modeling',
            methodologies: ['Emulators', 'Differentiable programming', 'SBI'],
            challenges: ['Scalability & compute efficiency', 'Model misspecification']
          },
          {
            id: 'sims',
            name: '3.1.7 Cosmological & Survey Simulations',
            shortName: 'Simulations',
            methodologies: ['Emulators', 'Generative models', 'Differentiable programming', 'SBI'],
            challenges: ['Covariate shift & domain adaptation']
          },
          {
            id: 'deblend',
            name: '3.2.1 Deblending',
            shortName: 'Deblending',
            methodologies: ['Generative models', 'SBI'],
            challenges: ['Metrics & evaluation']
          },
          {
            id: 'shape',
            name: '3.2.2 Shape measurement',
            shortName: 'Shape Measurement',
            methodologies: ['Differentiable programming', 'Deep learning', 'SBI'],
            challenges: ['Covariate shift & domain adaptation', 'UQ & calibration']
          }
        ];

        function processData() {
          const methodologyCount = new Map();
          const challengeCount = new Map();

          rawData.forEach(sc => {
            sc.methodologies.forEach(m => {
              methodologyCount.set(m, (methodologyCount.get(m) || 0) + 1);
            });
            sc.challenges.forEach(c => {
              challengeCount.set(c, (challengeCount.get(c) || 0) + 1);
            });
          });

          const methodologies = new Map();

          // Use consistent colors for each category
          const categoryColors = {
            scienceCase: { color: '#A10034', bgColor: '#fce7ed' },
            methodology: { color: '#93A8AC', bgColor: '#f0f3f4' },
            challenge: { color: '#F3C969', bgColor: '#fef9ed' }
          };

          methodologyCount.forEach((count, method) => {
            methodologies.set(method, {
              count,
              color: categoryColors.methodology.color,
              bgColor: categoryColors.methodology.bgColor
            });
          });

          return {
            scienceCases: rawData,
            methodologies,
            challenges: challengeCount
          };
        }

        function InteractiveDiagram() {
          const [hoveredMethod, setHoveredMethod] = useState(null);
          const [hoveredCase, setHoveredCase] = useState(null);
          const [hoveredChallenge, setHoveredChallenge] = useState(null);
          const [lockedSelection, setLockedSelection] = useState(null);
          const [paperMode, setPaperMode] = useState(false); // Default to interactive mode

          const data = useMemo(() => processData(), []);

          // Category color scheme
          const categoryColors = {
            scienceCase: { color: '#A10034', bgColor: '#fce7ed' },
            methodology: { color: '#93A8AC', bgColor: '#f0f3f4' },
            challenge: { color: '#F3C969', bgColor: '#fef9ed' }
          };

          const activeMethod = lockedSelection?.type === 'method' ? lockedSelection.value : hoveredMethod;
          const activeCase = lockedSelection?.type === 'case' ? lockedSelection.value : hoveredCase;
          const activeChallenge = lockedSelection?.type === 'challenge' ? lockedSelection.value : hoveredChallenge;

          const handleClick = (type, value) => {
            if (paperMode) return;
            if (lockedSelection?.type === type && lockedSelection?.value === value) {
              setLockedSelection(null);
            } else {
              setLockedSelection({ type, value });
            }
          };

          // Calculate circular positions
          const centerX = 600;
          const centerY = 500;
          const radius = 380;

          const allMethodologies = Array.from(data.methodologies.keys()).sort();
          const allChallenges = Array.from(data.challenges.keys()).sort((a, b) =>
            (data.challenges.get(b) || 0) - (data.challenges.get(a) || 0)
          );

          // Position calculations
          const casePositions = new Map();
          const methodPositions = new Map();
          const challengePositions = new Map();

          // Divide circle into three equal sections with small gaps for visual separation
          const gapAngle = 3; // Small gap between sections

          // Science cases: top-left (90° to 210°) - 120° section
          const caseStartAngle = 90 + gapAngle;
          const caseEndAngle = 210 - gapAngle;
          const caseSectionSize = caseEndAngle - caseStartAngle;
          const caseMargin = caseSectionSize * 0.1; // 10% margin on each end
          const caseAngleStep = (caseSectionSize - 2 * caseMargin) / Math.max(1, data.scienceCases.length - 1);

          data.scienceCases.forEach((sc, i) => {
            const angle = caseStartAngle + caseMargin + i * caseAngleStep;
            const rad = (angle * Math.PI) / 180;
            casePositions.set(sc.id, {
              x: centerX + radius * Math.cos(rad),
              y: centerY + radius * Math.sin(rad),
              angle
            });
          });

          // Methodologies: bottom (210° to 330°) - 120° section
          const methodStartAngle = 210 + gapAngle;
          const methodEndAngle = 330 - gapAngle;
          const methodSectionSize = methodEndAngle - methodStartAngle;
          const methodMargin = methodSectionSize * 0.05; // 5% margin on each end
          const methodAngleStep = (methodSectionSize - 2 * methodMargin) / Math.max(1, allMethodologies.length - 1);

          allMethodologies.forEach((method, i) => {
            const angle = methodStartAngle + methodMargin + i * methodAngleStep;
            const rad = (angle * Math.PI) / 180;
            methodPositions.set(method, {
              x: centerX + radius * Math.cos(rad),
              y: centerY + radius * Math.sin(rad),
              angle
            });
          });

          // Challenges: top-right (330° to 450° = 330° to 90°) - 120° section
          const challengeStartAngle = 330 + gapAngle;
          const challengeEndAngle = 450 - gapAngle; // 450° = 90° (wraps around)
          const challengeSectionSize = challengeEndAngle - challengeStartAngle;
          const challengeMargin = challengeSectionSize * 0.1; // 10% margin on each end
          const challengeAngleStep = (challengeSectionSize - 2 * challengeMargin) / Math.max(1, allChallenges.length - 1);

          allChallenges.forEach((challenge, i) => {
            const angle = challengeStartAngle + challengeMargin + i * challengeAngleStep;
            const rad = (angle * Math.PI) / 180;
            challengePositions.set(challenge, {
              x: centerX + radius * Math.cos(rad),
              y: centerY + radius * Math.sin(rad),
              angle
            });
          });

          // Determine highlights
          const getHighlightedCases = () => {
            const highlighted = new Set();
            if (activeMethod) {
              data.scienceCases.forEach(sc => {
                if (sc.methodologies.includes(activeMethod)) {
                  highlighted.add(sc.id);
                }
              });
            }
            if (activeChallenge) {
              data.scienceCases.forEach(sc => {
                if (sc.challenges.includes(activeChallenge)) {
                  highlighted.add(sc.id);
                }
              });
            }
            if (activeCase) {
              highlighted.add(activeCase);
            }
            return highlighted;
          };

          const getHighlightedMethods = () => {
            const highlighted = new Set();
            if (activeMethod) {
              highlighted.add(activeMethod);
            }
            if (activeCase) {
              const caseData = data.scienceCases.find(sc => sc.id === activeCase);
              caseData?.methodologies.forEach(m => highlighted.add(m));
            }
            if (activeChallenge) {
              data.scienceCases.forEach(sc => {
                if (sc.challenges.includes(activeChallenge)) {
                  sc.methodologies.forEach(m => highlighted.add(m));
                }
              });
            }
            return highlighted;
          };

          const getHighlightedChallenges = () => {
            const highlighted = new Set();
            if (activeChallenge) {
              highlighted.add(activeChallenge);
            }
            if (activeCase) {
              const caseData = data.scienceCases.find(sc => sc.id === activeCase);
              caseData?.challenges.forEach(c => highlighted.add(c));
            }
            if (activeMethod) {
              data.scienceCases.forEach(sc => {
                if (sc.methodologies.includes(activeMethod)) {
                  sc.challenges.forEach(c => highlighted.add(c));
                }
              });
            }
            return highlighted;
          };

          const highlightedCases = getHighlightedCases();
          const highlightedMethods = getHighlightedMethods();
          const highlightedChallenges = getHighlightedChallenges();

          const hasActiveSelection = !paperMode && (activeMethod || activeCase || activeChallenge);

          // Generate chord paths
          const generateChords = () => {
            const chords = [];

            data.scienceCases.forEach(sc => {
              const casePos = casePositions.get(sc.id);

              // Science cases to methodologies (grey)
              sc.methodologies.forEach(method => {
                const methodPos = methodPositions.get(method);
                const isHighlighted = paperMode ||
                  (highlightedCases.has(sc.id) && highlightedMethods.has(method));

                // Bezier curve from case to method through center
                const controlDist = 150;
                const path = `M ${casePos.x} ${casePos.y} Q ${centerX} ${centerY - controlDist} ${methodPos.x} ${methodPos.y}`;

                chords.push({
                  path,
                  color: categoryColors.methodology.color,
                  opacity: paperMode ? 0.25 : (isHighlighted ? 0.7 : 0.1),
                  strokeWidth: isHighlighted ? 3 : 2,
                  highlighted: isHighlighted
                });
              });

              // Science cases to challenges (red)
              sc.challenges.forEach(challenge => {
                const challengePos = challengePositions.get(challenge);
                const isHighlighted = paperMode ||
                  (highlightedCases.has(sc.id) && highlightedChallenges.has(challenge));

                // Direct Bezier curve from case to challenge through center
                const controlDist = 150;
                const path = `M ${casePos.x} ${casePos.y} Q ${centerX + controlDist} ${centerY} ${challengePos.x} ${challengePos.y}`;

                chords.push({
                  path,
                  color: categoryColors.scienceCase.color,
                  opacity: paperMode ? 0.2 : (isHighlighted ? 0.6 : 0.08),
                  strokeWidth: isHighlighted ? 2.5 : 1.5,
                  highlighted: isHighlighted
                });
              });
            });

            // Methodologies to challenges (yellow)
            // Connect a methodology to a challenge if any science case uses both
            const methodChallengeConnections = new Map();
            data.scienceCases.forEach(sc => {
              sc.methodologies.forEach(method => {
                sc.challenges.forEach(challenge => {
                  const key = `${method}::${challenge}`;
                  if (!methodChallengeConnections.has(key)) {
                    methodChallengeConnections.set(key, true);
                  }
                });
              });
            });

            methodChallengeConnections.forEach((_, key) => {
              const [method, challenge] = key.split('::');
              const methodPos = methodPositions.get(method);
              const challengePos = challengePositions.get(challenge);

              const isHighlighted = paperMode ||
                (highlightedMethods.has(method) && highlightedChallenges.has(challenge));

              // Bezier curve from method to challenge through center
              const controlDist = 150;
              const path = `M ${methodPos.x} ${methodPos.y} Q ${centerX} ${centerY + controlDist} ${challengePos.x} ${challengePos.y}`;

              chords.push({
                path,
                color: categoryColors.challenge.color,
                opacity: paperMode ? 0.2 : (isHighlighted ? 0.6 : 0.08),
                strokeWidth: isHighlighted ? 2.5 : 1.5,
                highlighted: isHighlighted
              });
            });

            return chords;
          };

          const chords = generateChords();

          return React.createElement('div', { className: 'bg-white rounded-xl shadow-lg border border-slate-200 p-8' },
            // Controls bar - always visible with toggle button
            React.createElement('div', { className: 'mb-6 flex items-center justify-between gap-6 flex-wrap pb-6 border-b border-slate-200' },
              // Legend and title - only shown in interactive mode
              !paperMode && React.createElement('div', { className: 'flex items-center gap-6' },
                React.createElement('div', { className: 'flex items-center gap-2' },
                  React.createElement('span', { className: 'text-slate-600' }, 'Interactive chord diagram')
                ),
                React.createElement('div', { className: 'flex items-center gap-4' },
                  React.createElement('div', { className: 'flex items-center gap-2' },
                    React.createElement('div', { className: 'w-4 h-4 rounded', style: { backgroundColor: categoryColors.scienceCase.color }}),
                    React.createElement('span', { className: 'text-slate-600' }, 'Science Cases')
                  ),
                  React.createElement('div', { className: 'flex items-center gap-2' },
                    React.createElement('div', { className: 'w-4 h-4 rounded', style: { backgroundColor: categoryColors.methodology.color }}),
                    React.createElement('span', { className: 'text-slate-600' }, 'Methodologies')
                  ),
                  React.createElement('div', { className: 'flex items-center gap-2' },
                    React.createElement('div', { className: 'w-4 h-4 rounded', style: { backgroundColor: categoryColors.challenge.color }}),
                    React.createElement('span', { className: 'text-slate-600' }, 'Challenges')
                  )
                )
              ),

              // Toggle button - always visible
              React.createElement('div', { className: 'flex items-center gap-3' + (paperMode ? ' ml-auto' : '') },
                React.createElement('button', {
                  onClick: () => {
                    setPaperMode(!paperMode);
                    setLockedSelection(null);
                  },
                  className: paperMode
                    ? 'px-4 py-2 rounded-lg border-2 transition-all flex items-center gap-2 border-indigo-500 bg-indigo-50 text-indigo-700'
                    : 'px-4 py-2 rounded-lg border-2 transition-all flex items-center gap-2 border-slate-300 bg-white text-slate-700 hover:border-slate-400'
                },
                  paperMode ? 'Switch to Interactive' : 'Switch to Paper Mode'
                ),

                lockedSelection && !paperMode && React.createElement('button', {
                  onClick: () => setLockedSelection(null),
                  className: 'px-4 py-2 bg-slate-100 hover:bg-slate-200 rounded-lg text-slate-700 transition-colors'
                }, 'Clear selection')
              )
            ),

            // Chord diagram
            React.createElement('div', { className: 'relative flex justify-center' },
              React.createElement('svg', { width: 1200, height: 1000, className: 'max-w-full' },
                React.createElement('defs', null,
                  React.createElement('filter', { id: 'glow' },
                    React.createElement('feGaussianBlur', { stdDeviation: '3', result: 'coloredBlur' }),
                    React.createElement('feMerge', null,
                      React.createElement('feMergeNode', { in: 'coloredBlur' }),
                      React.createElement('feMergeNode', { in: 'SourceGraphic' })
                    )
                  )
                ),

                // DESC Logo embedded in SVG at top left
                React.createElement('image', {
                  href: 'desc_logo.png',
                  x: 10,
                  y: 10,
                  height: 140,
                  preserveAspectRatio: 'xMinYMin meet'
                }),

                // Background circle with sections
                React.createElement('g', null,
                  // Full background circle
                  React.createElement('circle', {
                    cx: centerX,
                    cy: centerY,
                    r: radius,
                    fill: 'none',
                    stroke: '#f1f5f9',
                    strokeWidth: '1'
                  }),

                  // Section arcs with different colors
                  // Science cases section (90° to 210°)
                  React.createElement('path', {
                    d: `M ${centerX + radius * Math.cos(90 * Math.PI / 180)} ${centerY + radius * Math.sin(90 * Math.PI / 180)} A ${radius} ${radius} 0 0 1 ${centerX + radius * Math.cos(210 * Math.PI / 180)} ${centerY + radius * Math.sin(210 * Math.PI / 180)}`,
                    fill: 'none',
                    stroke: categoryColors.scienceCase.color,
                    strokeWidth: '6',
                    strokeOpacity: '0.4'
                  }),

                  // Methodologies section (210° to 330°)
                  React.createElement('path', {
                    d: `M ${centerX + radius * Math.cos(210 * Math.PI / 180)} ${centerY + radius * Math.sin(210 * Math.PI / 180)} A ${radius} ${radius} 0 0 1 ${centerX + radius * Math.cos(330 * Math.PI / 180)} ${centerY + radius * Math.sin(330 * Math.PI / 180)}`,
                    fill: 'none',
                    stroke: categoryColors.methodology.color,
                    strokeWidth: '6',
                    strokeOpacity: '0.4'
                  }),

                  // Challenges section (330° to 90°, wrapping around through 0°)
                  React.createElement('path', {
                    d: `M ${centerX + radius * Math.cos(330 * Math.PI / 180)} ${centerY + radius * Math.sin(330 * Math.PI / 180)} A ${radius} ${radius} 0 0 1 ${centerX + radius * Math.cos(90 * Math.PI / 180)} ${centerY + radius * Math.sin(90 * Math.PI / 180)}`,
                    fill: 'none',
                    stroke: categoryColors.challenge.color,
                    strokeWidth: '6',
                    strokeOpacity: '0.4'
                  }),

                  // Radial boundary lines
                  // Boundary at 90°
                  React.createElement('line', {
                    x1: centerX,
                    y1: centerY,
                    x2: centerX + (radius + 30) * Math.cos(90 * Math.PI / 180),
                    y2: centerY + (radius + 30) * Math.sin(90 * Math.PI / 180),
                    stroke: '#cbd5e1',
                    strokeWidth: '2',
                    strokeDasharray: '4,4',
                    opacity: '0.6'
                  }),

                  // Boundary at 210°
                  React.createElement('line', {
                    x1: centerX,
                    y1: centerY,
                    x2: centerX + (radius + 30) * Math.cos(210 * Math.PI / 180),
                    y2: centerY + (radius + 30) * Math.sin(210 * Math.PI / 180),
                    stroke: '#cbd5e1',
                    strokeWidth: '2',
                    strokeDasharray: '4,4',
                    opacity: '0.6'
                  }),

                  // Boundary at 330°
                  React.createElement('line', {
                    x1: centerX,
                    y1: centerY,
                    x2: centerX + (radius + 30) * Math.cos(330 * Math.PI / 180),
                    y2: centerY + (radius + 30) * Math.sin(330 * Math.PI / 180),
                    stroke: '#cbd5e1',
                    strokeWidth: '2',
                    strokeDasharray: '4,4',
                    opacity: '0.6'
                  })
                ),

                // Chords
                React.createElement('g', null,
                  chords.map((chord, idx) =>
                    React.createElement('path', {
                      key: idx,
                      d: chord.path,
                      stroke: chord.color,
                      strokeWidth: chord.strokeWidth,
                      strokeOpacity: chord.opacity,
                      fill: 'none',
                      strokeLinecap: 'round',
                      style: {
                        transition: 'all 0.3s ease',
                        filter: chord.highlighted && !paperMode ? 'url(#glow)' : 'none'
                      }
                    })
                  )
                ),

                // Science Cases
                data.scienceCases.map(sc => {
                  const pos = casePositions.get(sc.id);
                  const isHighlighted = highlightedCases.has(sc.id);
                  const isActive = activeCase === sc.id;
                  const isDimmed = hasActiveSelection && !isHighlighted;

                  const labelRadius = radius + 40;
                  const labelRad = (pos.angle * Math.PI) / 180;
                  const labelX = centerX + labelRadius * Math.cos(labelRad);
                  const labelY = centerY + labelRadius * Math.sin(labelRad);

                  return React.createElement('g', { key: sc.id },
                    React.createElement('circle', {
                      cx: pos.x,
                      cy: pos.y,
                      r: isActive ? 14 : 10,
                      fill: (paperMode || isHighlighted || isActive) ? categoryColors.scienceCase.color : categoryColors.scienceCase.bgColor,
                      stroke: categoryColors.scienceCase.color,
                      strokeWidth: isActive ? 3 : 2,
                      opacity: isDimmed ? 0.3 : 1,
                      className: paperMode ? '' : 'cursor-pointer',
                      style: { transition: 'all 0.2s ease' },
                      onMouseEnter: () => !lockedSelection && !paperMode && setHoveredCase(sc.id),
                      onMouseLeave: () => !lockedSelection && !paperMode && setHoveredCase(null),
                      onClick: () => handleClick('case', sc.id)
                    }),
                    React.createElement('text', {
                      x: labelX,
                      y: labelY,
                      textAnchor: pos.angle > 90 && pos.angle < 270 ? 'end' : 'start',
                      dominantBaseline: 'middle',
                      className: 'text-slate-700 pointer-events-none',
                      fontSize: '15',
                      fontWeight: isActive ? 'bold' : 'normal',
                      opacity: isDimmed ? 0.3 : 1,
                      style: { transition: 'all 0.2s ease' }
                    }, sc.shortName)
                  );
                }),

                // Methodologies
                allMethodologies.map(method => {
                  const pos = methodPositions.get(method);
                  const methodData = data.methodologies.get(method);
                  const isHighlighted = highlightedMethods.has(method);
                  const isActive = activeMethod === method;
                  const isDimmed = hasActiveSelection && !isHighlighted;

                  const labelRadius = radius + 50;
                  const labelRad = (pos.angle * Math.PI) / 180;
                  const labelX = centerX + labelRadius * Math.cos(labelRad);
                  const labelY = centerY + labelRadius * Math.sin(labelRad);

                  return React.createElement('g', { key: method },
                    React.createElement('circle', {
                      cx: pos.x,
                      cy: pos.y,
                      r: isActive ? 16 : 12,
                      fill: paperMode || isHighlighted || isActive ? methodData.color : methodData.bgColor,
                      stroke: methodData.color,
                      strokeWidth: isActive ? 4 : 2,
                      opacity: isDimmed ? 0.3 : 1,
                      className: paperMode ? '' : 'cursor-pointer',
                      style: { transition: 'all 0.2s ease' },
                      onMouseEnter: () => !lockedSelection && !paperMode && setHoveredMethod(method),
                      onMouseLeave: () => !lockedSelection && !paperMode && setHoveredMethod(null),
                      onClick: () => handleClick('method', method)
                    }),
                    React.createElement('text', {
                      x: labelX,
                      y: labelY,
                      textAnchor: 'middle',
                      dominantBaseline: 'middle',
                      className: 'text-slate-800 pointer-events-none',
                      fontSize: '14',
                      fontWeight: isActive ? 'bold' : '500',
                      opacity: isDimmed ? 0.3 : 1,
                      style: { transition: 'all 0.2s ease' }
                    }, method)
                  );
                }),

                // Challenges
                allChallenges.map(challenge => {
                  const pos = challengePositions.get(challenge);
                  const isHighlighted = highlightedChallenges.has(challenge);
                  const isActive = activeChallenge === challenge;
                  const isDimmed = hasActiveSelection && !isHighlighted;

                  const labelRadius = radius + 40;
                  const labelRad = (pos.angle * Math.PI) / 180;
                  const labelX = centerX + labelRadius * Math.cos(labelRad);
                  const labelY = centerY + labelRadius * Math.sin(labelRad);

                  return React.createElement('g', { key: challenge },
                    React.createElement('circle', {
                      cx: pos.x,
                      cy: pos.y,
                      r: isActive ? 14 : 10,
                      fill: (paperMode || isHighlighted || isActive) ? categoryColors.challenge.color : categoryColors.challenge.bgColor,
                      stroke: categoryColors.challenge.color,
                      strokeWidth: isActive ? 3 : 2,
                      opacity: isDimmed ? 0.3 : 1,
                      className: paperMode ? '' : 'cursor-pointer',
                      style: { transition: 'all 0.2s ease' },
                      onMouseEnter: () => !lockedSelection && !paperMode && setHoveredChallenge(challenge),
                      onMouseLeave: () => !lockedSelection && !paperMode && setHoveredChallenge(null),
                      onClick: () => handleClick('challenge', challenge)
                    }),
                    React.createElement('text', {
                      x: labelX,
                      y: labelY,
                      textAnchor: pos.angle > 270 || pos.angle < 90 ? 'start' : 'end',
                      dominantBaseline: 'middle',
                      className: 'text-slate-700 pointer-events-none',
                      fontSize: '15',
                      fontWeight: isActive ? 'bold' : 'normal',
                      opacity: isDimmed ? 0.3 : 1,
                      style: { transition: 'all 0.2s ease' }
                    }, challenge)
                  );
                }),

                // Section labels - centered on each arc
                // Science Cases label at 150° (midpoint of 90° to 210°) - LEFT side
                React.createElement('text', {
                  x: centerX + (radius + 200) * Math.cos(150 * Math.PI / 180),
                  y: centerY + (radius + 200) * Math.sin(150 * Math.PI / 180),
                  textAnchor: 'middle',
                  dominantBaseline: 'middle',
                  className: 'text-slate-500',
                  fontSize: '20',
                  fontWeight: '700'
                }, 'Science Cases'),
                // Methodologies label at 270° (midpoint of 210° to 330°) - TOP
                React.createElement('text', {
                  x: centerX + (radius + 100) * Math.cos(270 * Math.PI / 180),
                  y: centerY + (radius + 100) * Math.sin(270 * Math.PI / 180),
                  textAnchor: 'middle',
                  dominantBaseline: 'hanging',
                  className: 'text-slate-500',
                  fontSize: '20',
                  fontWeight: '700'
                }, 'Methodologies'),
                // Challenges label at 30° (midpoint of 330° to 90° via 0°) - RIGHT side
                React.createElement('text', {
                  x: centerX + (radius + 200) * Math.cos(30 * Math.PI / 180),
                  y: centerY + (radius + 200) * Math.sin(30 * Math.PI / 180),
                  textAnchor: 'middle',
                  dominantBaseline: 'middle',
                  className: 'text-slate-500',
                  fontSize: '20',
                  fontWeight: '700'
                }, 'Challenges')
              )
            )
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(InteractiveDiagram));
    </script>
</body>
</html>